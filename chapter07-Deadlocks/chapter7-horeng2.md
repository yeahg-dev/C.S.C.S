## Deadlock(교착상태)

일련의 프로세스들이 서로가 가진 자원을 기다리며 블락된 상태

### 자원이란?

- 하드웨어/소프트웨어 등을 포함하는 개념
    - I/O Device, CPU Cycle, Memory space, 세마포어 등
- 프로세스가 자원을 사용하는 절차
    
    

### Deadlock 발생의 조건 4가지

- Mutual exclusion(상호배제)
    - 매 순간 하나의 프로세스만이 자원을 사용할 수 있음
    - 공유해서는 안되는 자원의 경우 반드시 성립해야함
- No preemtion(비선점)
    - 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음
- Hold and wait(보유대기)
    - 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음
    - 방법1 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법
    - 방법2 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청
- Circular wait(순환대기)
    - 자원을 기다리는 프로세스간에 사이클이 형성되어야 함
    - 프로세스 P0...Pn이 있을 때
        - 앞에 프로세스가 뒤의 프로세스가 가진 자원을 기다림
        

### Resource-Allocation Graph

- 그래프에 사이클이 없으면 데드락이 아니다
- 그래프에 사이클이 있으면
    
    → 자원당 인스턴스가 하나만 있을 경우 데드락이다
    
    → 인스턴스가 여러개 있을 경우 데드락일 수도 있고 아닐 수도 있다
    

## 데드락의 처리 방법

### Deadlock Prevention

- Mutual exclusion(상호배제)
    - 공유해서는 안되는 자원의 경우 반드시 성립해야함
- No preemtion(비선점)
    - 프로세스가 어떤 자원을 기다려야하는 경우 이미 보유한 자원이 선점됨
    - 모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다
    - State를 쉽게 save하고 restore할 수 있는 자원에서 주로 사용(씨피유, 메모리)
- Hold and wait(보유대기)
    - 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음
    - 방법1: 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법
    - 방법2: 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청
- Circular wait(순환대기)
    - 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원 할당
    - 예를 들어 순서가 3인 자원 R1을 보유 중인 프로세스가 순서1인 자원 R2를 할당받기 위해서는 우선 R1을 release해야 한다.

→ 데드락을 원천적으로 막을 수 있지만 자원 이용률이 낮아지고 성능이 낮아진다.

### Deadlock Avoidance

지원 요청에 대한 부가정보를 이용해서 자원 할당이 데드락으로부터 안전한지 동적으로 조사해서 안전한 경우만 할당

- 자원에 대한 인스턴스가 1개인 경우
    - Claim edge P1→ R1
        - 프로세스1이 자원 1을 미래에 요청할 수 있음을 점선으로 표시
        - 프로세스가 해당 자원 요청 시 리퀘스트엣지로 바뀜(실선)
        - 자원1이 릴리즈되면 어사인먼트 엣지는 다시 클레임 엣지로 바뀐다
    - 리퀘스트 엑지의 어사인먼트 엣지 변경시(점선 포함) 싸이클이 생기지 않는 경우에만 요청 자원을 할당한다.
    - 싸이클 생성 여부 조사시 프로세스의 수가 n일 때 O(n^2) 시간이 걸린다
- 자원당 인스턴스가 여러개인 경우
    - Banker’s Algorithm
        - 프로세스가 자원을 요청했을 때 줄지말지 결정하는 것
        - 항상 최악의 경우를 가정하고 있음
        - 잠재적으로 최대의 자원 개수를 요청할 수 있는 걸 기준으로 가용자원을 비교한다
        - 가용자원과 프로세스가 최대로 요청할 수 있는 자원수

### Deadlock Detection and recovery

데드락 발생 허용하고 그에 대한 디텍션을 하고 데드락이 발생되면 리커버리한다

- 지원당 인스턴스 하나인 경우
    - 사이클 있으면 데드락
- 여러개인 경우
    - 뱅커스알고리즘과 유사한 방법 활용
- wait for 그래프 알고리즘
- 리커버리
    - process termination
        - 데드락에 관련된 프로세스를 모두 킬한다
        - 하나씩 프로세스를 킬 한다
    - resource preemption
        - 데드락에 관련된 프로세스 중에서 하나에게서 자원을 빼앗는다
        - 동일한 프로세스가 계속 걸리는 경우 코스트에 데드락 횟수도 포함

### Deadlock Ignorance

- 데드락이 일어나지 않는다고 가정하고 아무 조치도 취하지 않음
- 데드락이 매우 드물게 발생하므로 조치 자체가 더 큰 오버헤드일 수 있음
- 만약 데드락이 발생해서 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 방법으로 대처
- 현재 대부분의 OS가 이 방법을 채택
