# 2️⃣ 컴퓨터 시스템 구조 & 프로그램 실행

## 1. 컴퓨터 시스템 구조 (하드웨어)

- CPU
    - register (Program Counter, Accumulator, Instruction Register, Status Register,,,)
    - 산술논리연산장치(ALU)
    - 제어장치
- Memory
- I/O Device
    - device controller
    - local buffer
- DMA controller
- Timer

### CPU

> 클럭사이클마다 메모리에서 명령어를 읽어와서 실행시킴

- **register** : 속도가 빠른 메모리
    - program counter: 다음 실행될 명령어의 주소를 갖고 있음, Program Counter가 가리키는 메모리 주소에서 기계어를 읽어와서 수행, 그 다음 interrupt를 체크함. interrupt 가 있으면 CPU는 운영체제에게 넘어감.
- **mode bit** : CPU에서 처리하는 것이 운영체제인지 사용자 프로그램인지 구분해줌
    - 목적: CPU에서 처리 가능한 명령어를 제한하여, 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 보호하기 위함
    - CPU가 OS ↔️ 사용자 프로그램을 오갈 때마다 mode bit가 셋팅됨

    1. 커널 모드(모니터 모드, 시스템 모드) : mode bit `0` , 커널 코드 수행
    2. 유저 모드 : mode bit `1` , 사용자 프로그램 코드 수행
    - 커널 모드 일 땐 올마이티, I/O 관련 코드까지 모두 수행 가능
    - 커널 모드에서만 수행 가능한 명령어를 “특권 명령"으로 규정

>입력과 출력에 관한 명령어를 만나면 디바이스 컨트롤러에게 알림. 작업이 완료되면 CPU에게 인터럽트를 걸고 운영체제에게 CPU 사용권이 돌아감. 만약 입출력에 대한 결과값이 필요한 프로그램에 아직 결과가 안 도착하면 다른 프로그램에게 CPU를 넘겨주기도함.
핵심은 CPU는 쉬지 않고 일 한다...

### I/O device

> 입력장치, 출력장치

### **Deviece controller**

> 각 디바이스를 전담하는 일종의 작은 CPU

- 제어 정보를 위해 control register, status register를 갖고 있음
- 입출력 결과 같은 데이터를 저장하기 위햔 local buffer를 가짐
- I/O가 끝나면 interrupt로 CPU에게 알림

### Timer

> 정해진 시간이 경과하면 인터럽트를 발생시켜 운영체제에게 제어권을 넘기는 장치

- 목표 : 무한루프를 도는 프로그램이 실행되면 CPU를 독점 할 수도 있음, 그래서 타이머로 시간을 나눠서 독정을 방지하기  위함.
- 타이머는 매 클럭 틱마다 1씩감소하고, 0이되면 인터럽트 발생
- time sharing을 구현하기 위해 널리 이용됨
- 운영체제가 사용자 프로그램마다 시간을 할당함. 시간이 다되면 CPU 사용권이 다시 운영체제에게 넘어감
- 할당된 시간(수십에서 수백 밀리 세컨)이 되면 interrupt를 걸고, interrupt line 체크하고, CPU의 사용권이 프로그램에서 운영체제로 넘어감

> ⭐️즉 타이머를 갖고 각 사용자 프로그램에게 CPU사용 시간을 할당해주고 관리하는 역할을 운영체제가 담당함.
>
> 사용자 프로그램은 직접 I/O 장치에 접근 불가. OS 통해서만 가능. I/O를 해야하는 코드를 만나면 운영체제에게 CPU를 넘김. 

### DMA Controller (Direct Memory Access Controller)

> 메모리에 직접 접근하는 장치

- 목표 :  I/O의 잦은 인터럽트를 방지해 CPU를 좀 더 효율적으로 사용하게 하기 위함 (CPU와 I/O 디바이스는 처리 속도 차이가 많이 남.)
- I/O의 로컬 버퍼의 값을 직접 메모리에 접근해 전송하고 block이 채워지면 인터럽트를 걸음. 바이트 단위가 아니라 block단위로 인터럽트를 발생시킴


---

## 2. 입출력(I/O)의 수행

모든 입출력 명령은 OS만 수행가능 (특권 명령)

따라서 사용자 프로그램이 입출력을 하려면 운영체제에게 부탁해야함.

### System call

> 운영체제에게 부탁하는 것, 사용자 프로그램이 운영체제의 서비스를 사용하기 위해 **커널 함수 호출 요청 하는 것  = 인터럽트 라인 셋팅**


사용자 프로그램이 인터럽트 라인을 셋팅해서 운영체제에게 CPU를 넘김. 그럼 CPU는 인터럽트 벡터로 처리 루틴의 주소를 확인하고, 루틴이 올바른 지(수행해도 되는 것인지) 체크 후 수행 → I/O 컨트롤러에게 일 시킴

- 인터럽트 벡터 : 각 인터럽트에 대한 처리 루틴 명령어의 주소를 정리한 표

### 인터럽트(Interrupt)

인터럽트 당한 시점의 레지스터와 Program Counter를 저장한 후, CPU의 제어를 인터럽트 처리 루틴에게 넘김

- 보통 인터럽트라고 하면 하드웨어 인터럽트를 말함(device controller, timer에 의한)
- Expection이나 System Call에 의한 인터럽트는 **Trap**(소프트웨어 인터럽트)라고 함

### 동기식 입출력과 비동기식 입출력

- 동기식 입출력
    - I/O 요청 후 입출력 작업이 완료된 후에야 CPU가 사용자 프로그램에게 넘어가는 방식
- 비동기식 입출력
    - I/O 요청 후 입출력 작업의 완료를 기다리지 않고, 사용자 프로그램이 CPU를 계속 사용하면서 다른 코드를 실행 시키는 방식

---

## 3. 저장장치 계층 구조

- CPU에서 직접 접근 할 수 있는 매체를 Primary (Register, Cache Memory, Main Memory)
    CPU는 바이트 단위로 접근 가능해야함.
    
- 아닌 것을 Secondary (Magnetic Disk, Optical Disk)

---

## 4. 프로그램의 실행

각 프로그램만의 독자적인 메모리 공간이 생김 (Virtual Memory)
- 이 메모리 공간은 `stack` `data`  `code` 로 구분함

그리고 이 가상 메모리를 실제 물리적 메모리에 올려서 사용함
근데 모든 프로그램의 메모리를 전부 다 올리는 것은 아님... 당장 필요한 부분만 올려 놓음.
가상 메모리에서 물리 메모리로 옮길 때 주소변환(Address translation)을 함. 주소변환을 해주는 하드웨어 장치가 있음

### Physical Memory

- 사용자 영역
- 커널 영역

- Swap area : 메모리의 연장선상으로 사용됨. (전원이 나가면 증발됨)

### 커널 주소 공간의 내용

- **code** : 커널 코드 / 시스템 콜, 인터럽트 처리 코드, 자원 관리를 위한 코드, 편리한 서비스 제공을 위한 코드
- **data** : 운영체제가 사용하는 자료구조가 저장되어 있음 (CPU, Memory, Disk 관련) + PCB(Process Control Block, 프로그램을 관리하기 위한 자료구조)
- **stack** : 각 프로세스의 호출 코드?
