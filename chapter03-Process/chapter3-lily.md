## Process

메모리에 올라와 실행중인 프로그램

## 프로세스의 문맥(Context) == 프로그램이 어디까지 왔나?

> 알아야하는 이유: 타임 쉐어링, CPU가 여러개의 프로세스를 처리하므로, 프로세스가 바뀔 때마다 마지막 문맥을 기억하고 있어야 이어서 진행할 수 있음
> 
- CPU 수행 상태를 나타내는 하드웨어 문맥
    - 프로그램 카운터가 어딜 가리키고 있는가 == 프로세스가 어디까지 진행되었는가
    - 각종 register에 뭐가 들었었는지
- 프로세스의 주소 공간
    - 현재 시점의 주소 공간(code, data, stack)에 무엇이 들어있는가?
- 프로세스 관련 커널 자료 구조
    - 프로세스가 하나 생성될 때마다 PCB가 생성됨, PCB는 커널 주소공간의 data영역에 저장됨
    - PCB : “운영체제가 현재 프로세스에 대해서 어떻게 평가하고 있는가”
    - Kernal Stack : 시스템콜에 대한 호출 스택, 어떤 프로세스가 커널을 호출했는지에 따라 별도의 스택을 두고 있음.

## 프로세스의 상태 (Process State)
CPU가 하나라고 가정하고 프로세스의 상태를 보자.

> 💡 운영체제가 프로세스를 보는 관점에서 상태를 나눈 것

- **Running**
    - 현재 CPU를 잡고 명령어를 수행중인 상태
- **Ready**
    - CPU를 기다리는 상태 (프로세스가 메모리에 올라가 있음, CPU만 되찾으면 당장 수행 가능)
    - Timer interrupt를 당했을 때 이 경우가 됨
- **Blocked(wait, sleep)**
    - CPU를 주어도 당장 명령어를 수행할 수 없는 상태
    - 요청한 작업 (I/O 같이 오래걸리는)이 만족되지 않아 이를 기다리는 상태.
    - 명령어가 디스크에서 메모리에 올라와있지 않아서 당장 수행 불가능한 상태
    - ⭐️ **자신이 요청한 이벤트가 끝나면 Ready로 변경**
- **Suspended**
    - 외부적인 이유(중기 스케줄러, 사용자)로 메모리에서 프로세스를 빼앗은 상태
    - 프로세스는 통째로 디스크에  swap out됨
    - 여기서 상태 변경은 사용자가 복구할 수 잇음
    - ⭐️ 외부에서 resume해주어어야 Active로 변경 (외부란 사람)
- New : 프로세스가 생성중인 상태
- Terminated : 수행이 끝난 상태, 정리하는 상태

## 프로세스들은 Queue로 관리 됨

프로세스들은 상태마다 큐에 줄 서있음, 프로세스는 각 큐를 오가며 수행됨

무조건 선입선출은 아님 (우선순위가 높은 것 먼저)

- Ready Queue
- Disk I/O Queue (blocked)
- Keyboard I/O Queue (blocked)
- Resource Queue (blocked)

## PCB(Process Control Block)

> 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보 (커널의 데이터 영역에 저장)
> 
- OS가 관리상 사용하는 정보
    - Process state, Process ID
    - scheduling information, priority
- CPU 수행 관련 하드웨어 값
    - Program Counterm register
- 메모리 관련
    - code, data, stack의 위치 정보
- 파일 관련
    - open file descriptors

## Context Switch

> CPU를 **한 프로세스**에서 **다른 프로세스**로 넘겨주는 과정


사용자 프로세스에서 운영체제로 넘어가는 것은 컨텍스트 스위치가 아님! (예를 들면, 시스템콜)

- 컨텍스트 스위치가 발생할 때 운영체제는 다음을 수행
    - 기존에 수행되고 있던 프로세스의 상태를 해당 프로세스의 PCB에 저장
    - CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴

- **Cache Memory flush** : 상당한 오버헤드, 컨텍스트 스위치 일어날때 캐시메모리를 지워야함.
    - 커널모드와 유저모드를 오가는 오버헤드 보다 더 큼, 몇 십배(인터럽트 당한 시점의 레지스터와 Program Counter를 저장한 후, CPU의 제어를 인터럽트 처리 루틴에게 넘김)

## 스케줄러 
- 장기 스케줄러(Job Scheduler)
    - new인 프로세스에 메모리를 줄지 말지 결정
    - 메모리에 프로세스 몇개를 줄지를 관리!
    - degree of mulitprogramming : 메모리에 올라간 프로그램의 수
    - 너무 많은 프로그램 올려도 성능이 안좋아짐.
    - time sharing system 에서는 장기 스케줄러가 없음. 다 메모리에 올려놓고 사용함. (무조건 Ready)
- 단기 스케줄러 (CPU Scheduler)
    - 다음에 어떤 프로세스에게 CPU를 줄지 결정함
    - 충분히 빨라야함 (millisecond단위)
- 중기 스케줄러 (Swapper)
    - 메모리에 다 올려 놓고, 공간 마련을 위해 프로세스를 메모리에서 디스크로 쫓아냄
    - degree of Multiprogramming을 제어

## Thread

> CPU 수행단위

공유할 수 있는 건 공유하되, CPU 수행과 관련된 정보는 스레드별로 따로 관리

- Stack영역에 스레드별로 분류
- PCB에서 CPU관련 정보 (PC, register 정보) 를 스레드 별로 저장

### 스레드 사용하면 좋은 점
1. 스레드 하나가 블락일 때, 다른 스레드가 실행되어 빠른 처리 가능 
2. 사용자에게 좋은 경험성 제공 가능(통신) , 빠른 응답성 제공
3. 자원 공유 그래서 효율적
4. 스레드간의 스위칭은 오버헤드가 적음(컨텍스트 스위칭에 비해) 
5. 다중 프로세서 환경에서는 병령 프로그래밍이 가능
